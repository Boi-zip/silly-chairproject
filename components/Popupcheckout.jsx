'use client'
import Popup from 'reactjs-popup';
import { useState } from 'react';
import "./Css/Popup.css"
import 'animate.css'

export default function Popupcheckout(items) {
  const [isActive, setIsActive] = useState(false);

  const start = () => {
    var audio = document.getElementById('a1');
    audio.play()
  }
  const [pricetotal, setPricetotal] = useState(0);
  function updateprice() { //Generated by Gemini for more reliable counting
  const total = items.items.reduce((sum, item) => sum + Number(item.price), 0);
  setPricetotal(total);
}
  
  {/*By using reactjs-popup this works */}
  
  return (
    <div>
       <audio id="a1" src="https://cdn.pixabay.com/download/audio/2022/12/17/audio_43e9af63f3.mp3?filename=cashier-quotka-chingquot-sound-effect-129698.mp3"></audio>
      <Popup onOpen={() => updateprice()} onClose={() => setIsActive(false)} trigger={<button className="trigger-button">üõíÔ∏è Checkout</button>} position="right center" modal nested>
        {close => (
          <div className="modal">
            <button className="close scale-125" onClick={close}>
              &times;
            </button>
            <div className="header"> <span className='text-2xl'>Simple checkout menu </span></div>
            <div className="content">
              
  {(() => { //Used AI Gemini here, explained to understand the code better
    // 1. Group the items and count quantities
    const groupedItems = items.items.reduce((acc, item) => { //do a 'run', check items
      if (acc[item.text]) { //if atleast 1 exists
        acc[item.text].quantity += 1; //add 1 more item to total quantity, so like 2x item instead of item item
        acc[item.text].totalPrice += Number(item.price); //add the items price to total price(only of the item, not the checkout)
      } else { //first time seeing the item
        acc[item.text] = { //set item
          ...item, //all properties of it
          quantity: 1, //first time seeing the item, so 1
          totalPrice: Number(item.price) //the price of the item
        };
      }
      return acc; //return item
    }, {}); //that {} thing, is what we start with(empty)

    // 2. Map over the grouped object
    return Object.values(groupedItems).map((item, index) => (
      <div key={index} className="flex justify-between border-b pb-1 mb-1">
        <span className='text-lg'>
          {item.quantity > 1 && <b className="text-blue-500">{item.quantity}x </b>}
          {item.text}
        </span>
        <p className='price text-lg font-mono'>‚Ç¨ {item.totalPrice.toFixed(2)}</p>
      </div>
    ));
  })()}
</div>
            <div className="actions">
              <button className={`button animate__animated text-xl ${isActive && 'animate__hinge'}`} onClick={() => {
                start(); setIsActive(true)
              }}>Buy all üí∏Ô∏è</button>
              <p className='price ml-5 text-xl'>Total: ‚Ç¨{pricetotal}</p>
            </div>
          </div>
        )}
      </Popup>
    </div>
  );
}